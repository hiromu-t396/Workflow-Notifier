import{a as g}from"./auth-ae73c97e.js";async function w(){try{const r=await(await fetch(chrome.runtime.getURL(".env"))).text(),n={};return r.split(`
`).forEach(o=>{const[e,c]=o.split("=");e&&c&&(n[e.trim()]=c.trim())}),{GITHUB_CLIENT_ID:n.GITHUB_CLIENT_ID,GITHUB_CLIENT_SECRET:n.GITHUB_CLIENT_SECRET,CHECK_INTERVAL:60*1e3,REDIRECT_URL:chrome.identity.getRedirectURL()}}catch(t){throw console.error("Failed to load config:",t),t}}let a=null,h=null;async function u(){try{a=await w(),chrome.storage.local.get(["githubToken"],t=>{t.githubToken&&(h=t.githubToken,k())})}catch(t){console.error("Failed to initialize:",t)}}async function f(){try{const t=chrome.identity.getRedirectURL(),r=`https://github.com/login/oauth/authorize?client_id=${a.GITHUB_CLIENT_ID}&redirect_uri=${encodeURIComponent(t)}&scope=repo`,n=await chrome.identity.launchWebAuthFlow({url:r,interactive:!0});if(chrome.runtime.lastError)throw new Error(chrome.runtime.lastError);const o=new URL(n).searchParams.get("code");if(!o)throw new Error("No auth code received");const e=await d(o);return h=e,await chrome.storage.local.set({githubToken:e}),e}catch(t){throw console.error("Authentication failed:",t),t}}async function d(t){return(await(await fetch("https://github.com/login/oauth/access_token",{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({client_id:a.GITHUB_CLIENT_ID,client_secret:a.GITHUB_CLIENT_SECRET,code:t})})).json()).access_token}async function s(){var t,r;try{console.log("Checking workflow status...");const o=(await chrome.storage.local.get(["watchingRepos"])).watchingRepos||[];if(console.log("Watching repos:",o),!o.length){console.log("No repositories to watch");return}for(const e of o){console.log(`Checking repo: ${e.owner}/${e.repo}, branch: ${e.branch}`);const c=await fetch(`https://api.github.com/repos/${e.owner}/${e.repo}/actions/runs?branch=${e.branch}`,{headers:{Authorization:`token ${await g.getToken()}`,Accept:"application/vnd.github.v3+json"}});if(!c.ok){console.error(`API request failed: ${c.status}`);continue}const l=await c.json();console.log("Workflow data:",(t=l.workflow_runs)==null?void 0:t[0]);const i=(r=l.workflow_runs)==null?void 0:r[0];i&&p(e,i)&&(console.log("Creating notification for:",i),T(e,i),m(e,i))}}catch(n){console.error("Error checking workflow status:",n)}}function p(t,r){if(console.log("Checking notification conditions:"),console.log("Repo state:",t),console.log("Current run:",r),!t.lastKnownState)return console.log("First time notification - no previous state"),!0;if(t.lastKnownState.id!==r.id)return console.log("New workflow run detected"),!0;const n=t.lastKnownState.status!==r.status,o=t.lastKnownState.conclusion!==r.conclusion;return console.log("Status changed:",n,"Conclusion changed:",o),n||o}async function m(t,r){try{let o=(await chrome.storage.local.get("watchingRepos")).watchingRepos||[];o=o.map(e=>e.owner===t.owner&&e.repo===t.repo&&e.branch===t.branch?(console.log("Updating state for repo:",e),{...e,lastKnownState:{id:r.id,status:r.status,conclusion:r.conclusion}}):e),await chrome.storage.local.set({watchingRepos:o}),console.log("Updated watching repos:",o)}catch(n){console.error("Error updating last known state:",n)}}function T(t,r){const n=`Workflow ${r.name} - ${r.conclusion}`,o=`Repository: ${t.owner}/${t.repo}
Branch: ${t.branch}
Status: ${r.status}`;console.log("Creating notification:",{title:n,message:o});const e=chrome.runtime.getURL("public/icons/icon48.png");chrome.notifications.create({type:"basic",iconUrl:e,title:n,message:o,priority:2,requireInteraction:!0},c=>{chrome.runtime.lastError?console.error("Notification error:",chrome.runtime.lastError):console.log("Notification created with ID:",c)})}function k(){s(),setInterval(s,6e4)}chrome.runtime.onInstalled.addListener(()=>{u()});chrome.runtime.onMessage.addListener((t,r,n)=>{if(t.type==="authenticate")return f().then(o=>n({success:!0,token:o})).catch(o=>n({success:!1,error:o.message})),!0;if(t.type==="checkNow")return s().then(()=>n({success:!0})).catch(o=>n({success:!1,error:o.message})),!0});u();
